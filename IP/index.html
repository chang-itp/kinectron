<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js canvas - geometry - birds</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #808080;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            background-color: #ffffff;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 5px;
        }
    </style>
</head>

<body>

    <div id="container"></div>
    <!-- <div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - birds demo</div> -->

    <script src="shared/three.js"></script>
    <script src="shared/Projector.js"></script>
    <script src="shared/CanvasRenderer.js"></script>
    <!-- <script src="shared/stats.min.js"></script> -->
    <script src="shared/Plane.js"></script>

    <script id="PlaneCPUInstance-fs" type="x-shader/x-fragment">
    uniform sampler2D tMatCap;
    uniform float alpha;
    varying vec2 vUVMatCap;
    varying float vReleased;
    void main() {
      gl_FragColor = texture2D(tMatCap, vUVMatCap);
      gl_FragColor.a *= alpha;
      gl_FragColor.a *= vReleased;
    }
    </script>

    <script id="PlaneCPUInstance-vs" type="x-shader/x-fragment">

    attribute vec3 offset;
    attribute vec4 orientation;
    attribute vec3 random;
    attribute float released;

    uniform float time;
    varying vec2 vUVMatCap;
    varying float vReleased;
    #require(matcap.vs)
    void main() {

    vReleased = released;

    // Update vertex positions based on offset and orientation buffers
    vec3 pos = position;

    pos *= random;

    vec4 or = orientation;
    vec3 vcV = cross(or.xyz, pos);
    pos = vcV * (2.0 * or.w) + (cross(or.xyz, vcV) * 2.0 + pos);
    pos += offset;

    pos.x += (1.0 - released) * 10000.0;

    // Update normals as well for matcap to work
    vec3 nml = normal;
    vec3 vcn = cross(or.xyz, normal);
    nml = vcn * (2.0 * or.w) + (cross(or.xyz, vcn) * 2.0 + nml);

    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);

    vUVMatCap = reflectMatcap(gl_Position.xyz, modelViewMatrix, nml);
  }
  </script>
  <script src="b_sketch.js"></script>
  <script src="World.js"></script>

</body>

</html>
